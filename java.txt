1、常量的类型：
字符常量：'a','中'
字符串常量："hello,world."
整型常量：123
浮点型常量：-3.14
布尔常量：布尔数据类型只有两个值true和false，他们不对应任何整数值，默认值是false
空常量：null


基本数据类型（四类八种基本数据类型）：
	整数： 字节型：byte（1个字节）；短整型：short（2个字节）；整型：int（4个字节）；长整型：long（8个字节）
	浮点数：单精度浮点型：float（4个字节）；双精度浮点型：double（8个字节）
	字符型：char（2个字节，0-65535）
	布尔型：boolean（1个字节）
	
注意：
    数据表示范围与字节数并不一定相关，例如float的数据范围比long更大。
    整数默认类型是int，如果要使用long，需要加一个后缀L/l。
	浮点数默认类型是double，如果要使用float，需要加一个后缀F/f。
	
	强制数据类型转换：范围小的变量名 = （范围小的类型）原本范围比较大的数据
	byte/short/char都可以发生数学运算，首先会被提升为int类型，再进行运算
	boolean不能发生数据类型转换

引用数据类型：
	字符串：String(不是关键字)
	数组：
	类：
	接口：
	lambda:


2、java变量区分大小写

3、逻辑运算符：&&、||、！，只能作用于布尔值
&&、||具有短路效果


4、三元运算符
数据类型 变量名称 = 条件判断？表达式A：表达式B
注意：必须同时保证表达式A和表达式B都符合左侧数据类型的要求


5、switch语句注意事项：  
	1、switch后面的小括号中只能是以下数据类型：
		基本数据类型：byte,short,char,int
		引用数据类型：String,enum
	2、case后面的值不能重复

6、循环结构

for(初始化表达式;布尔表达式;步进表达式){
循环体；
}

while(条件判断)
{
循环体;
}

do{
循环体；
}
while(条件判断); //这里有个;

7、idea快速生成代码
psvm
5.fori
sout
shift+F6：批量重命名

8、方法定义
修饰符  返回值类型 方法名称（参数类型 参数名称, ...）{
方法体;
return 返回值;  //对于一个void没有返回值的方法，直接写一个return;或者省略
}

9、方法重载：多个方法名称一样，但是参数列表不一样
方法的重载与参数的名称、方法的返回值类型无关，只跟参数列表个数、类型是否一致有关
例如下面这个是错误的：
public static int sum(int a, int b){
	return a+b;
}

public static double sum(int a, int b){
	return a+b+0.0;
}


10、数组
数组是一种引用数据类型，数组中的数据，类型必须统一；数组的长度在程序运行期间不可改变。

初始化要么指定长度，要么指定内容；

动态初始化是指由程序员在初始化数组时指定数组的长度，由系统为数组元素分配初始值。
动态初始化： 数据类型[] 数组名称 = new 数据类型[数组长度]；
数组动态初始化，具体示例如下：

int[ ] array = new int[10]; // 动态初始化数组
array[0]=1;
array[1]=2;

动态初始化默认值：
	整数类型:byte,short,int,long默认初始化值都是0
	浮点类型:float,double默认初始化值都是0.0
	布尔类型:boolean默认初始化值false
	字符类型:char默认初始化值'\u0000'
	引用数据类型：null
	char在内存中占的两个字节,是16个二进制位
	\u0000,每一个0其实代表的是16进制的0,那么四个0就是代表16个二进制位
 
	[I@19bb25a
 
	[代表是数组,几个就代表几维
	I代表是int类型
	@是固定的
	19bb25a代表的是数组的地址值


静态初始化是指由程序员在初始化数组时为数组每个元素赋值，由系统决定数组的长度。

数组的静态初始化有两种方式：
	静态初始化完整格式： 数据类型[] 数组名称 = new 数据类型[] {值1,值2,...};
	静态初始化省略格式： 数据类型[] 数组名称 ={值1,值2,...};

具体示例如下：

int[ ] array = new int[ ]{1,2,3,4,5};
可以拆分为：
int[] array;
array=new int[]{1,2,3,4,5};

静态初始化省略格式，此处注意只有在定义数组的同时执行数组初始化才支持使用简化的静态初始化。
int[ ] array = {1,2,3,4,5};

静态初始化省略格式不能拆分为2个步骤：下面这种方式是错误的：
int[] arrayA;
arrayA={1,2,3,4};  //错误的


Arrays.toString(arr)

数组的长度：array.length;

11、java内存划分
栈：
	存放的都是方法中的局部变量，方法的参数、方法{}内部的变量，一旦超出作用域，立刻从栈内存中消失。方法的运行一定要在栈中
堆：
	凡是new出来的东西，都在堆中。堆中有个字符串常量池。
方法区：
	存储.class相关信息
本地方法栈：
	与操作系统相关
寄存器：
	与CPU相关
	

12、局部变量和成员变量

局部变量：在方法的内部定义，基本数据类型没有默认值，要使用得先赋值；位于栈内存，随着方法进栈而诞生，随着方法出栈而消失。
成员变量：在方法的外部，直接写在类中，基本数据类型也有默认值。位于堆内存，随着对象创建而诞生，随着垃圾回收而消失。

当方法的局部变量和类的成员变量同名的时候，根据就近原则，优先使用方法的局部变量。如果需要访问本类中的成员变量，需要使用this关键字。this.成员变量名

13、面向对象三大特征：封装、继承、多态

封装：隐藏对象的属性和实现细节，只对外提供必要的公共方法对其访问
继承：继承可以让子类具有父类的特性，提高了代码的复用性，同样的代码不用重复的编写
多态：同一个方法调用，由于传的对象不同可能会产生不同的行为。多态可以增加代码的灵活度，它是以继承和重写父类方法为前提。


14、构造方法注意事项
构造方法的名称必须和类名称一样，就连大小写也要一样
构造方法不要写返回值类型，就连void也不要，有void就不是构造函数
构造函数不能return一个返回值。
如果没有编写构造方法，那么会默认赠送一个无参数，方法体什么都不做的构造方法。如果编写了至少一个构造方法，那么不再会有默认的构造方法。
构造方法也是可以重载的。

格式：public 类名称(参数类型 参数名称){
	方法体;
}


一个标准的类通常拥有下面4个组成部分：
1.所有的成员变量都要用private关键字修饰
2.为每一个成员变量编写一对getter/setter方法
3.编写一个无参构的造方法
4.编写一个全参数的构造方法


15、对象数组
数组的长度不可以发生改变，但ArrayList集合的长度是可以随意变化的
对于ArrayList来说，有个尖括号<E>代表泛型。泛型，也就是说装在集合里的元素，都统一是什么类型。泛型只能是引用数据类型，不能是基本类型。对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。如果内容是空的，得到的是[].

ArrayList<String> list = new ArrayList<>();

向集合中添加数据，用到add方法：
list.add("zjd");

String name=list.get(0);     //获取index位置元素:返回获取index索引的值
String name=list.remove(0);  //删除index位置元素：返回删除的值

int size = list.size();   //集合的长度

list.fori  //idea快速生成代码


基本类型     包装类型
byte         Byte
short        Short
int          Integer
long 		 Long
float        Float
double       Double
char         Character
boolean      Boolean

16、创建字符串的常见3+1种方式(3种常用构造方法，一种直接创建)：
public String();  //创建一个空白字符串，不含有任何内容。
public String(char[] array);  //根据字符数组，创建对应的字符串。
public String(byte[] array);  //根据字节数组，创建对应的字符串。

byte[] byteArray = {97,98,99};
String str = new String(byteArray);

所有的双引号字符串，都是String类的对象。
双引号字符串，即字符串字面量在堆中的常量池中，而new的字符串是在堆中。(只有双引号直接用的字符串才是在常量池中)
字符串的内容永不可变；所以字符串是可以共享使用的。

直接创建： String str = "hello";


String str1 = "abc";
String str2 = "abc";
String str3= new String("hello");

#对于引用类型来说，==是对地址值的比较。
System.out.println(str1==str2);  #true
System.out.println(str1==str3);  #false


字符串内容的比较：
推荐使用"abc".equals(str5); //常量字符串写在前面，只有参数是字符串且内容相同时，才会返回true。
如果是str5.equals("abc")，那么假如str5为null时，就报错了。

"hello".equalsIgnoreCase(str5);  //忽略大小写

str5.length(): 获取字符串的长度
str1.concat(str2);  //拼接成新字符串
str1.charAt(index);   //返回索引index处的单个字符
str1.indexOf(str2);   //返回参数字符串str2在str1中,首次出现的位置，如果查找不到，返回-1；

str1.substring(beginIndex)；  //截取从beginIndex开始到末尾的字符串
str1.substring(beginIndex,endIndex); //截取从beginIndex开始到endIndex的字符串(包含begin，不包含end)
str1.replace(target,replacement);  //替换字符串,eg: "helloworld".replace("o","*);

str1.split("\\.");  //按.进行分割字符串；

str1.toCharArray();  //字符串转换成字符数组

18、键盘输入：
Scanner sc = new Scanner(System.in);


19、
静态方法只能访问静态成员
静态方法中不可以写this，super关键字：因为this代表对象，而静态在时，有可能没有对象，所以this无法使用。
主函数是静态的 

20、静态代码块：当第一次用到本类时，静态代码块执行唯一的一次
静态代码块比构造方法先执行
格式：
    static {
        System.out.println("静态代码块执行了...");
    }
    


21、如果有一个对象确定只需要使用唯一的一次，那么就可以使用匿名对象。
比如只需要输入一次：
int num = new Scanner(System.in).nextInt();

22、对于引用数据类型来说，未初始化，那么值为null；

String[] str = new String[3];
System.out.println(str[0]); //null

boolean[] b = new boolean[5];
System.out.println(b[0]);   //false

Boolean[] b = new Boolean[5];
System.out.println(b[0]);   //null

boolean b2 = b[0]   //即boolean b2=null;报空指针异常

23、数组工具类Arrays
Arrays.toString(数组): 将数组变成字符串，格式：[元素1，元素2...]
Arrays.sort(数组)：对数组进行排序，返回值是void，直接把数组排好序，默认是升序排序。


24、继承,extends
在继承关系中，方法的名称一样，参数列表也一样，那么就叫重写（override）
方法重写的注意事项：
	子类方法的返回值范围必须【小于等于】父类方法的返回值范围。
	子类方法的权限必须【大于等于】父类方法的权限修饰符
		public > protected > (default) > private   #default不是关键字default,而是什么都不写，留空。

继承关系中，子类构造方法里面有一个隐含的"super()"调用，也可以明确使用super()调用父类的重载构造方法.

java语言是单继承的，一个类的直接父类只能有唯一的一个。可以多级继承
	
	

25、抽象
如果父类当中的方法体不确定怎么实现，那么可以定义为一个抽象方法;抽象方法所在的类，必须为抽象类；

抽象方法格式：修饰符 abstract 返回值类型 方法名称(参数列表);  #不要{}

使用抽象类时，不能直接new来创建一个抽象类，必须创建一个子类继承抽象类，而且子类必须重写父类中所有的抽象方法。

抽象类中，可以有构造方法。
抽象类，不一定就有抽象方法。但有抽象方法的类，一定是抽象类。


26、接口
接口是引用数据类型

接口就是多个类的公共规范
定义一个接口的格式：
public interface 接口名称{

}

在任何版本的jdk版本中，接口都能定义抽象方法；

如果是java 7, 接口中可以包含的内容有：
1、常量
2、抽象方法（如果写必须是固定的public abstract，但也可以省略）

如果是java 8, 接口中还可以额外包含：
3、默认方法
4、静态方法

如果是java 9, 接口中还可以额外包含：
5、私有方法


接口不能直接使用，必须有一个实现类来实现该接口，格式：
public class 实现类名称 implements 接口名称{

}
而且如果这个实现类没有覆盖重写所有的抽象方法，那么这个实现类就必须是抽象类


从java 8 开始，接口中允许定义默认方法，格式：
public default 返回值类型 方法名称(参数列表){

}
接口当中的默认方法，可以解决接口升级的问题，新添加的方法，设置为默认方法。


从java 8 开始，接口中允许定义静态方法，格式：
public static 返回值类型 方法名称(参数列表){

}
不能通过接口实现类的对象来调用接口中的静态方法，应该通过接口名称直接调用静态方法。


从java 9开始，接口中允许定义私有方法（可以用来解决私有方法中重复代码的问题，抽取出来作为一个私有方法 ）：

1、普通私有方法，格式：
	private 返回值类型 方法名称(参数列表）{
	
	}
	
2、静态私有方法
	private static 返回值类型 方法名称(参数列表）{
	
	}

	
接口中的变量为常量，使用public static final修饰（不写也是这个），必须初始化赋值；

注意事项：
	1、接口是没有静态代码块和构造方法的。
	2、一个类可以实现多个接口
	3、如果实现类中的多个接口有重名的默认方法，那么一定要对该方法进行覆盖重写（override）
	4、如果一个类的直接父类中的方法，和接口当中的默认方法同名，那么优先使用父类中的方法。
	5、接口与接口之间是多继承的。(可以继承多个接口)
	

override：在继承关系中，方法的名称一样，参数列表也一样。  #可添加注解@Override
重写方法不能抛出新的检查异常或者比被重写方法申明更加宽泛的异常。例如： 父类的一个方法申明了一个检查异常 IOException，但是在重写这个方法的时候不能抛出 Exception 异常，因为 Exception 是 IOException 的父类，只能抛出 IOException 的子类异常。 

声明为 final 的方法不能被重写。

声明为 static 的方法不能被重写

 
overload：是在一个类里面，方法名字相同，但参数列表不同。



继承中构造方法的访问特点：
1、子类构造方法必须调用父类的构造方法，而且子类构造方法中不写则默认会有个super（）构造方法
2、子类中的构造方法，才能调用super()构造方法，且该构造方法中，只能有一个super（）构造方法。

