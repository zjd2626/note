估算并发用户数方法：

 计算并发用户数的五种方法
一、经典公式1：
   一般来说，利用以下经验公式进行估算系统的平均并发用户数和峰值数据
 
  1）平均并发用户数为: C = nL/T
  2）并发用户数峰值为: C1 = C + 3*根号C
    C是平均并发用户数，n是login session的数量，L是login session的平均时间，T是考察的时间长度
    C1是并发用户数峰值
 
  举例1，假设系统A，该系统有3000个用户，平均每天大概有400个用户要访问该系统（可以从系统日志从获得），对于一个典型用户来说，一天之内用户从登陆到退出的平均时间为4小时，而在一天之内，用户只有在8小时之内会使用该系统。
  那么，
  平均并发用户数为：C = 400*4/8 = 200

  如果你要计算并发用户峰值的话，用另外一个公式
	C1=C + 3 * sqr(C)  #C表示并发用户数
  根据上面算出的结果，并发用户数是200，那么结果为：C1= 200+3*sqr(200)=242
  

  举例2， 某公司为其170000名员工设计了一个薪酬系统，员工可进入该系统查询自己的薪酬信息，但并不是每个人都会用这个系统，假设只有50%的人会定期用该系统，这些人里面有70%是在每个月的最后一周使用一次该系统，且平均使用系统时间为5分钟。
  则一个月最后一周的平均并发用户数为（朝九晚五）：
  n = 170000*0.5*0.7/5 = 11900
  C= 11900*5/60/8 = 124
 
  吞吐量计算为：F = Vu * R / T 单位为个/s
    F为事务吞吐量，Vu为虚拟用户数个数，R为每个虚拟用户发出的请求数，T为处理这些请求所花费的时间
 
二、通用公式2：
  对绝大多数场景，我们用（用户总量/统计时间）*影响因子（一般为3）来进行估算并发量。
  比如，以乘坐地铁为例子，每天乘坐人数为5万人次，每天早高峰是7到9点，晚高峰是6到7点，根据8/2原则，80%的乘客会在高峰期间乘坐地铁，则每秒到达地铁检票口的人数为50000*80%/（3*60*60）=3.7，约4人/S，考虑到安检，入口关闭等因素，实际堆积在检票口的人数肯定比这个要大，假定每个人需要3秒才能进站，那实际并发应为4人/s*3s=12，当然影响因子可以根据实际情况增大！
 
三、根据PV计算公式（一天中有80%的请求发生在一天的40%的时间内。24小时的40%是9.6小时）：
  比如一个网站，每天的PV大概1000w，我们可以认为这1000w pv的80%是在一天的9.6个小时内完成的，那么TPS为：
  1000w*80%/(9.6*3600)=231个/s,取经验因子3，则并发量应为：
  231*3=693

四、根据TPS估计：
   公式为 C = (Think time + 1)*TPS

五、根据系统用户数计算：
   并发用户数 = 系统最大在线用户数的8%到12%

=========================================================================

11-8,100k+

12-27推文：
峰值(18点50)   33k


QPS=33000min/60=550


uv=2600/min =43/s
平均响应时间=0.073s

QPS（TPS）= 并发数/平均响应时间 =550


QPS*平均响应时间=并发数



请求数：17.84k/10s
uv：    3.5k/10s



低峰：
10个闸门，每个人进站0.01s，每秒进站2个人  QPS=10/0.5=20

高峰时间：
10个闸门，每个人进站2s，每秒进站5个人   QPS=10/2=5

QPS=并发数/2=5



下面找一个典型的上班签到系统，早上8点上班，7点半到8点的30分钟的时间里用户会登录签到系统进行签到。公司员工为1000人，平均每个员上登录签到系统的时长为5分钟。可以用下面的方法计算。
　　　　C=1000/30*5=166.7
C表示平均并发用户数，那么对这个签到系统每分钟的平均在线用户数为166

当然，在性能测试上，任何公式都不是严谨的，最重要的是对系统做出有效正确的分析。




一、应用系统性能评价指标

 

    响应时间：尽快的给用户返回响应，体现系统处理请求的速度；

    吞吐量TPS：每秒完成的事务数，体现系统处理能力；

    并发数：业务请求高并发时，系统能否稳定运行；
	
	资源使用率：

    扩展性：单机处理能力不足时，系统能否横向扩展。

 
一方面用一个watch命令即时查看资源的使用情况，
一方面用nmon监控linux系统的资源消耗信息，并能把结果输出到文件中，然后通过nmon_analyser工具产生数据文件与图形化结果

TPS = 并发用户数 / (响应时间+Think Time)


24*0.2
5月8日推文:  
一天内的请求数：418w  
	418*10000*0.8/(8*3600)=116  C=116*经验因子3=348
	C1=C + 3 * sqr(C)=348+3*sqrt(348)=403.9

一个小时内的请求数：141w，平均22.7k/min（378/s）。最高请求数：41.4k/min（690/s)

QPS=并发用户数/响应时间

并发用户数=QPS*响应时间=376*1



=========================================================================================================
性能测试流程：
1、需求分析阶段：了解被测系统的技术信息，如系统架构，实现逻辑，提取性能需求，明确测试目标和范围
2、测试计划阶段：确定测试方案，进度安排，制定测试计划，测试场景
3、资源准备阶段：技术准备、选择合适的测试工具，搭建测试环境，构造测试数据
4、测试设计阶段：设计场景、开发脚本。
5、测试执行阶段：测试执行、资源监控。
6、测试分析阶段：分析测试数据、性能调优。回归测试。
7、测试总结：测试报告


性能测试遇到的问题：
1、性能压力大导致消息堆积而占用内存，以至于在性能测试时，生成庞大数量的临时对象，GC时没有做出有效回收甚至根本就不能回收，造成内存空间不足，内存溢出GC时没有做出有效回收甚至根本就不能回收，造成内存空间不足，内存溢出。

解决办法：
编码之前，对内存使用量进行预估，对放在内存中的数据进行评估，保证有用的信息尽快释放，无用的信息能够被GC回收，这样在一定程度上是可以避免内存溢出问题的。

2、并发问题：助力分享领券，重复领券问题
比如一个活动需要3个人助力成功，假如有个人发起的活动，已经满2个人助力了，这时候发一个500个人的群里，同时助力。导致多个人同时完成助力，重复领券；加入redis分布式锁（setnx实现），走队列。


=========================================================================================================

1、压力测试和负载测试的区别

压力测试主要是考察软件系统在既定负载下的性能表现。就是站在用户的角度去观察一定条件下软件系统的性能表现。期望结果是用户的性能指标需求得到满足。性能指标一般体现为响应时间、并发数、吞吐率、资源使用率等。

负载测试是通过不断加压去发现系统的瓶颈，能让我们知道极限负载下程序将如何运行，以发现系统可能存在的性能瓶颈、内存泄漏、不能实时同步等问题。负载测试更多地体现了一种方法或一种技术。


2、请描述什么是吞吐量？

答案：单位时间内系统处理用户的请求数。

 
从业务角度看，吞吐量可以用：请求数/秒、业务数/秒、人数/天或处理业务数/小时等单位来衡量

 
从网络角度看，吞吐量可以用：字节/秒来衡量

 
对于交互式应用来说，吞吐量指标反映的是服务器承受的压力，它能够说明系统的负载能力


3、一个web系统，用户从打开浏览器输入网址页面显示在浏览器中，这个过程当中，页面给用户总的响应时间通常可以细分为哪些？

答案：从客户端到服务端的请求时间（请求网络传输时间request），服务器的处理时间（应用服务器+数据库服务器处理时间），从服务端返回数据到客户端的时间（响应网络传输时间response），页面渲染时间（客户端浏览器加载页面的时间）

4、一份性能测试计划，通常包含哪些内容？

答案：测试目的，测试质量目标，测试环境，测试阶段和范围，测试策略，测试时间安排，测试用例


5、响应时间和吞吐量直接的关系是什么？

答案：

吞吐量图显示的是虚拟用户每秒钟从服务器接收到的字节数。当和响应时间比较时，可以发现随着吞吐量的降低，响应时间也降低，同样的，吞吐量的峰值和最大响应时间差不多在同时出现。

平均响应时间越短，系统吞吐量越大；平均响应时间越长，系统吞吐量越小；


6、如何识别性能瓶颈？

答案：找出最先出问题的点，即短板，再进行分析。


首先，要先做一份现有系统的性能测试报告，如CPU消耗、内存消耗、磁盘I/O、网卡I/O、带宽、页面交换等，如果发现其中一项或多项达到瓶颈，那么就要考虑是硬件不够导致性能上不去，还是系统实现不合理导致满了；如果是硬件问题，那么就早考虑扩容；如果是资源都没到极限或确认系统实现有问题，那么就要针对性的对系统相应功能进行相应的拆解或者是监控函数级的耗时。

7、请解释什么是内存泄露，内存泄露的危害有哪些？

答案：内存泄漏是指对象不再被应用程序使用，但是垃圾回收器却不能回收它们，因为它们正在被引用。

对于长时间运行的程序来说，内存泄漏会使程序占用的内存一直增加，最后就会出现内存耗尽而导致宕机，即使不宕机也会是系统的运行越来越慢，还有就是有些内存有其他资源，比如数据库连接，网络连接等等这些，如果在网上会出现阻塞。



=============================================================================
内存泄漏：不会再被使用的对象的内存不能被回收，就是内存泄露。比如你向系统申请分配内存进行使用(new)，可是使用完了以后却不释放(delete)，结果你申请到的那块内存你自己也不能再访问，该块已分配出来的内存也无法再使用，随着服务器内存的不断消耗，而无法使用的内存越来越多，系统也不能再次将它分配给需要的程序，一直下去，程序也逐渐无内存使用，就会溢出。内存泄漏并非指内存在物理上的消失，而是应用程序分配某段内存后，由于设计错误，失去了对该段内存的控制。


内存泄露的原因大体可以归为：
1、不正确使用单例模式是引起内存泄漏的一个常见问题，单例对象在初始化后将在 JVM 的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被 JVM 正常回收，导致内存泄漏

class A{ 
public A(){ 
B.getInstance().setA(this); 
} 
.... 
} 
//B类采用单例模式 
class B{ 
private A a; 
private static B instance=new B(); 
public B(){} 
public static B getInstance(){ 
return instance; 
} 
public void setA(A a){ 
this.a=a; 
} 
//getter... 
} 
显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况

2、创建大量无用对象，比如说当我们需要进行大量的字符串拼接时，使用的是String构造，而不是Stringbulider。

3、静态集合类的使用：像HashMap、Vector、List等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，所有的对象Object也不能被释放。大量的静态集合类容易造成内存泄漏。
像HashMap、Vector等的使用最容易出现内存泄露，这些静态变量的生命周期和应用程序一致，他们所引用的所有的对象Object也不能被释放，因为他们也将一直被Vector等引用着。 
例: 
Static Vector v = new Vector(10); 
for (int i = 1; i<100; i++) 
{ 
Object o = new Object(); 
v.add(o); 
o = null; 
}// 
在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。

当集合里面的对象属性被修改后，再调用remove（）方法时不起作用。
public static void main(String[] args) 
{ 
Set<Person> set = new HashSet<Person>(); 
Person p1 = new Person("唐僧","pwd1",25); 
Person p2 = new Person("孙悟空","pwd2",26); 
Person p3 = new Person("猪八戒","pwd3",27); 
set.add(p1); 
set.add(p2); 
set.add(p3); 
System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:3 个元素! 
p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变 

set.remove(p3); //此时remove不掉，造成内存泄漏
set.add(p3); //重新添加，居然添加成功 
System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:4 个元素! 
for (Person person : set) 
{ 
System.out.println(person); 
} 
}

4、各种连接对象(IO流对象、数据库连接对象、网络连接对象)未关闭：IO流对象、数据库连接对象、网络连接对象等连接对象属于物理连接，和硬盘或者网络连接，不使用的时候一定要关闭。比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，除非其显式的调用了其close（）方法将其连接关闭，否则是不会自动被GC 回收的。对于Resultset 和Statement 对象可以不进行显式回收，但Connection 一定要显式回收，因为Connection 在任何时候都无法自动回收，而Connection一旦回收，Resultset 和Statement 对象就会立即为NULL。但是如果使用连接池，情况就不一样了，除了要显式地关闭连接，还必须显式地关闭Resultset Statement 对象（关闭其中一个，另外一个也会关闭），否则就会造成大量的Statement 对象无法释放，从而引起内存泄漏。

5、监听器的使用：释放对象时，没有删除相应的监听器。

6、内部类和外部模块的引用：内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放。此外程序员还要小心外部模块不经意的引用，例如程序员A 负责A 模块，调用了B 模块的一个方法如： public void registerMsg(Object b); 这种调用就要非常小心了，传入了一个对象，很可能模块B就保持了对该对象的引用，这时候就需要注意模块B 是否提供相应的操作去除引用。


以发生的方式来分类，内存泄漏可以分为4类：

　　1.常发性内存泄漏。发生内存泄漏的代码会被多次执行到，每次被执行的时候都会导致一块内存泄漏。

　　2.偶发性内存泄漏。发生内存泄漏的代码只有在某些特定环境或操作过程下才会发生。常发性和偶发性是相对的。对于特定的环境，偶发性的也许就变成了常发性的。所以测试环境和测试方法对检测内存泄漏至关重要。

　　3. 一次性内存泄漏。发生内存泄漏的代码只会被执行一次，或者由于算法上的缺陷，导致总会有一块仅且一块内存发生泄漏。比如，在类的构造函数中分配内存，在析构函数中却没有释放该内存，所以内存泄漏只会发生一次。

　　4. 隐式内存泄漏。程序在运行过程中不停的分配内存，但是直到结束的时候才释放内存。严格的说这里并没有发生内存泄漏，因为最终程序释放了所有申请的内存。但是对于一个服务器程序，需要运行几天，几周甚至几个月，不及时释放内存也可能导致最终耗尽系统的所有内存。所以，我们称这类内存泄漏为隐式内存泄漏。

========================================================
内存溢出：
内存溢出通俗理解就是内存不够，是指运行程序时要求的内存，超出了系统所能分配的范围，从而导致发生内存溢出。内存溢出主要是由于代码编写时对某些方法、类应用不合理，或者没有预估到临时对象会占用很大内存量，或者把过多的数据放入JVM缓存。

1、上传大文件报空指针：
首先要排查SpringMvc的配置文件中对文件上传大小的限制是否过于小，未达到要求。
如果排查过配置文件没有问题后，那就去排查是否是tomcat的JVM内存设置过小导致内存溢出。

2、编写代码的时候，对某些方法和类设计的不合理，或者没有预估到临时对象会占用大量内存。

3、把过多的数据放入到JVM缓存

4、性能压力大导致消息堆积而占用内存，以至于在性能测试时，生成庞大数量的临时对象，GC时没有做出有效回收甚至根本就不能回收，造成内存空间不足，内存溢出GC时没有做出有效回收甚至根本就不能回收，造成内存空间不足，内存溢出。

如果编码之前，对内存使用量进行预估，对放在内存中的数据进行评估，保证有用的信息尽快释放，无用的信息能够被GC回收，这样在一定程度上是可以避免内存溢出问题的。

============================================================

空指针异常的原因：
1、内存分配未成功，却使用了它。
2、内存分配虽然成功，但是尚未初始化就引用它。
============================================================


请描述什么是系统性能拐点？

答案：性能开始急剧下降的点。

============================================================
对于一个缺乏性能明确需求的项目，你是如何提取性能需求的？

答案：与产品业务方交流，查看历史日志，跟同类产品对比，根据以往的经验。

============================================================
4、什么时候可以开始执行性能测试？

在产品相对比较稳定，功能测试结束后。灵活性比较强。




